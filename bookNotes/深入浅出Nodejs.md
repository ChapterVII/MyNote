# 深入浅出Nodejs

Node的模块实现：

模块分类：

​       核心模块：在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中。引入时，文件定位和编译执行可以省略，并且在路径分析中优先判断，所以加载速度最快。

​       文件模块：在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。

1. 优先从缓存加载

Node对引入过的模块都会进行缓存，以减少二次引入的开销，缓存的是编译和执行之后的对象。核心模块的缓存检查先于文件模块

1. 路径分析和文件定位

- 基于标识符进行模块查找，标识符分类：
- 核心模块，如http,      fs, path等
- .或..开始的相对路径文件模块
- 以/开始的绝对路径文件模块
- 非路径形式的文件模块，如自定义的connect模块

1. 核心模块：如果想加载自己编写的http用户模块，必须选择一个不同的标识符或换用路径方式
2. 路径形式：require方法会将路径转为真实路径，并以真实路径做索引，将编译执行后的结果存放到缓存中，使二次加载时更快，加载速度慢于核心模块
3. 自定义模块：可能是一个文件或者包的形式。查找最费时，最慢

模块路径：是Node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。在加载过程中，会逐个尝试模块中的路径，知道找到目标文件为止。当前文件路径越深，查找耗时约多，因此自定义模块加载最慢。

- 文件定位
- 文件扩展名分析：require分析标识符时，会出现标识符中不包含文件扩展名的情况，会按.js、.json、.node的次序补足扩展名，依次尝试。尝试需要调用fs模块同步阻塞式地判断文件是否存在。因为node单线程，会引起性能问题。所以，如果是.node和.json文件，带上扩展名，会快一点；同步配合缓存，可以大幅度缓解node单线程中阻塞式调用的缺陷
- 目录分析和包：require分析文件扩展名之后可能没有查找到对用文件，但却得到一个目录，在引入自定义模块和逐个模块路径进行查找时经常会出现，此时会将目录当作一个包来处理。首先，在当下目录查找package.json，通过JSON.parse()解析出包描述对象，从中取出main属性置顶的文件名进行定位。如果缺少扩展名，将会进入扩展名分析的步骤。如果main指定的文件名错误，或压根没有package.json文件，会将index当作默认文件名，然后依次查找index.js、index.json、index.node。如果没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有找到，则会抛出查找失败的异常。

1. 模块编译：定位到文件后，node会新建一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法不同：

.js文件：通过fs模块同步读取文件后编译执行。

.node文件：用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件

.json文件：通过fs模块同步读取文件后，用JSON.parse()解析返回结果

其余扩展名文件：都被当成.js文件载入

每一个编译成功的模块都会将文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。

## Node简介

### Node的诞生历程

### Node的命名与起源

- 考虑到高性能、符合事件驱动、没有历史包袱这3个主要原因，JavaScript成为了Node的实现语言

### Node给JavaScript带来的意义

- Node与浏览器的对比

  ![Chrome VS Node](https://github.com/GrowLegend/MyNote/blob/master/static/images/Chrome%20VS%20Node.png)

  - 浏览器中除了V8作为JavaScript引擎外还有一个WebKit布局引擎。HTML5在发展过程中定义了更多更丰富的API。在实现上，浏览器提供了越来越多的功能暴露给Javascript和HTML标签。但对于前端浏览器的发展现状而言，HTML5标准统一的过长是相对缓慢的。Javascript作为一门图灵完备的语言，长久以来却限制在浏览器的沙箱中运行，它的能力取决于浏览器中间层提供的支持有多少。
  - 除了HTML、webKit和显卡这些UI相关技术没有支持外，Node与Chrome十分相似。都是基于事件驱动的异步架构，浏览器通过事件驱动来服务界面上的交互，Node通过事件驱动来服务I/O。Node打破了过去JavaScript只能在浏览器中运行的局面。前后端编程环境统一，可以大大降低前后端转换所需要的上下文交换代价。

### Node的特点

将前端中广泛运用的思想迁移到了服务器端。

- 异步I/O：Node中绝大多数的操作都以异步的方式进行调用，底层构建了很多异步I/O，从文件读取到网络请求等。意义在于，可以从语言层面很自然地进行并行I/O操作。每个调用之间无须等待之前地I/O调用结束。在编程模型上可以极大提升效率。

- 事件与回调函数：事件地编程方式具有轻量级、松耦合、只关注事务点等优势，但在多个异步任务的场景下，事件与事件之间各自独立，如何协作是一个问题。回调函数是最好的接受异步调用返回数据的方式。

- 单线程：Node中JavaScript与其余线程是无法共享任何状态的。

  - 好处：不用处处在意状态的同步问题，没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。

  - 弱点：

    - 无法利用多核CPU
    - 错误会引起整个应用退出，应用的健壮性值得考验。
    - 大量计算占用CPU导致无法继续调用异步I/O。

    Node采用了child_process来解决单线程中大计算量的问题。子进程的出现，意味着Node可以从容地应对单线程在健壮性和无法利用多核CPU方面地问题。通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过 进程之间地事件消息来传递结果，可以很好地保持应用模型地简单和低依赖。通过Master-Worker的管理方式，也可以很好地管理各个工作进程，以达到更高地健壮性。

- 跨平台：兼容Windows和*nix平台主要得益于Node在架构层面的改动，在操作系统与Node上层模块系统之间构建了一层平台层架构，即libuv。libuv已成为许多系统实现跨平台的基础组件。通过良好的架构，Node的第三方C++模块也可以借助libuv实现跨平台。

  ![Node跨平台](https://github.com/GrowLegend/MyNote/blob/master/static/images/Node跨平台.png)

### Node的应用场景

- I/O密集型：Node面向网络且擅长并行I/O，能够有效地组织起更多的硬件资源，从而提供更好的服务。I/O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少。
- CPU密集型
  - V8的执行效率是十分高的。Node优秀的运算能力主要来自V8的深度性能优化。
  - CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起，这样既可同时享受到并行异步I/O的好处，又能充分利用CPU。I/O阻塞造成的性能浪费远比CPU的影响小。
  - 对于长时间运行的计算，如果耗时超过普通阻塞I/O的耗时，那么应用场景就需要重新评估，因为这类计算比阻塞I/O还影响效率，甚至说就是一个纯计算的场景，根本没有I/O。
    - Node可以通过编写C/C++扩展的方式更高效地利用CPU，将一些V8不能做到性能极致地地方通过C/C++来实现。
    - 如果单线程地Node不能满足需求，甚至用了C/C++扩展后还觉得不够，那么通过子进程的方式，将一部分Node进程当做常驻服务进程用于计算，然后利用进程间的消息来传递结果，将计算与I/O分离，这样还能充分利用多CPU。
- 与遗留系统和平共处：旧有的系统具有非常稳定的数据输出，持续为传统网站服务，同时为移动版提供数据源，Node将该数据源当作数据接口，发挥异步并行的优势，而不用关心背后是用什么语言实现的。
- 分布式应用：对可伸缩性的要求非常高

### Node的使用者

- 前后端编程语言环境统一：雅虎Cocktail框架。
- Node带来的高性能I/O用于实时应用：Voxer实时语音，腾讯朋友网长连接，花瓣网、蘑菇街通过socket.io实时通知。
- 并行I/O使得使用者可以更高效地利用分布式环境：阿里巴巴的NodeFox、eBay的ql.io。
- 并行I/O，有效利用稳定接口提升Web渲染能力：雪球财经和LinkedIn的移动版网站。
- 云计算平台提供Node支持：微软Azure、阿里云、百度云服务器提供Node应用托管服务。
- 游戏开发领域：网易pomelo实时框架
- 工具类应用

## 模块机制

### CommonJS规范

- 愿景：希望JavaScript能在任何地方运行。

- 主要是为了弥补当前JavaScript没有标准的缺陷：

  - 没有模块系统。
  - 标准库较少：ECMAScript仅定义了部分核心库，对于文件系统、I/O流等常见需求却没有标准的API。
  - 没有标准接口：JavaScript几乎没有定义过如Web服务器或数据库之类的标准统一接口。
  - 缺乏包管理系统：导致JavaScript应用中基本没有自动加载和安装依赖的能力。

  以达到像Python、Ruby、Java具备开发大型应用的基础能力，而不是停留在小脚本程序的阶段。期望用CommonJS API写出的应用可以具备跨宿主环境执行的能力，不仅可以利用JavaScript开发富客户端应用，还可以编写以下应用。

  - 服务器端JavaScript应用程序。
  - 命令行工具。
  - 桌面图形界面应用程序。
  - 混合应用。

- CommonJS规范涵盖了模块、二进制、Buffer、字符集编码、I/O流、进程环境、文件系统、套接字、单元测试、Web服务器网关接口、包管理等。

- Node能以一种熟悉的姿态出现，离不开CommonJS规范的影响；CommonJS能以一种寻常的姿态写进各个公司的项目代码中，离不开Node优异的表现

  ![Node和CommonJS关系](https://github.com/GrowLegend/MyNote/blob/master/static/images/Node和CommonJS关系.png)

- CommonJS的模块规范

  1. 模块引用：require()方法
  2. 模块定义：对应引入的功能，上下文提供了exports对象用于导出当前模块的方法或者变量，是唯一导出的出口。模块中还存在一个module对象，代表模块自身，而exports是module的属性。Node中一个文件就是一个模块。
  3. 模块标识：传递给require()方法的参数，必须是符合小驼峰命名的字符串，或路径，可以没有文件名后缀.js。

  ```javascript
  // math.js
  exports.add = function() {}
  
  // program.js
  var math = require('math');
  exports.increment = function(val) {
      return math.add(val, 1);
  }
  ```

  模块的意义：将类聚的方法和变量等限定在私有的作用域中，同时支持引入和导出共嗯那个以顺畅地连接上下游依赖。

### Node的模块实现

### 核心模块

### C++扩展模块

### 模块调用栈

### 包与NPM

### 前后端共用模块

### 总结

### 参考资源

## 异步I/O

### 为什么要异步I/O

### 异步I/O实现现状

### Node的异步I/O

### 非I/O的异步API

### 事件驱动与高性能服务器

### 总结

### 参考资源

## 异步编程

### 函数式编程

### 异步编程的优势与难点

### 异步编程解决方案

### 异步并发控制

### 总结

### 参考资源

## 内存控制

### V8的垃圾回收机制与内存限制

### 高效使用内存

### 内存指标

### 内存泄漏

### 内存泄漏排查

### 大内存应用

### 总结

### 参考资源

## 理解Buffer

### Buffer结构

### Buffer的转换

### Buffer的拼接

### Buffer与性能

### 总结

### 参考资源

## 网络编程

### 构建TCP服务

### 构建UDP服务

### 构建HTTP服务

### 构建WebSocket服务

### 网络服务与安全

### 总结

### 参考资源

## 构建Web应用

### 基础功能

### 数据上传

### 路由解析

### 中间件

### 页面渲染

### 总结

### 参考资源

## 玩转进程

### 服务模型的变迁

### 多进程架构

### 集群稳定之路

### Cluster模块

### 总结

### 参考资源

## 测试

### 单元测试

### 性能测试

## 产品化

### 项目工程化

### 部署流程

### 性能

### 日志

### 监控报警

### 稳定性

### 异构共存

### 总结

### 参考资源
