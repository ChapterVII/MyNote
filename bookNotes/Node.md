---
title: Node
date: 2018-11-30 18:49:19
tags:
---

CommonJS模块规范：

模块引用： var math = require('math') require方法接受模块标识，以此引入一个模块的API到上下文中。

模块定义：在node中一个文件就是一个模块，模块中，存在一个module对象，代表模块自身，module的属性exports用于到处当前模块的方法或变量，是唯一导出的出口。

模块标识：传递给require()方法的参数，必须是符合小驼峰命名的字符串，或者路径



Node的模块实现：

模块分类：

​       核心模块：在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中。引入时，文件定位和编译执行可以省略，并且在路径分析中优先判断，所以加载速度最快。

​       文件模块：在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢。

1. 优先从缓存加载

Node对引入过的模块都会进行缓存，以减少二次引入的开销，缓存的是编译和执行之后的对象。核心模块的缓存检查先于文件模块

1. 路径分析和文件定位

- 基于标识符进行模块查找，标识符分类：

- 核心模块，如http,      fs, path等
- .或..开始的相对路径文件模块
- 以/开始的绝对路径文件模块
- 非路径形式的文件模块，如自定义的connect模块

1. 核心模块：如果想加载自己编写的http用户模块，必须选择一个不同的标识符或换用路径方式
2. 路径形式：require方法会将路径转为真实路径，并以真实路径做索引，将编译执行后的结果存放到缓存中，使二次加载时更快，加载速度慢于核心模块
3. 自定义模块：可能是一个文件或者包的形式。查找最费时，最慢

模块路径：是Node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。在加载过程中，会逐个尝试模块中的路径，知道找到目标文件为止。当前文件路径越深，查找耗时约多，因此自定义模块加载最慢。

- 文件定位

- 文件扩展名分析：require分析标识符时，会出现标识符中不包含文件扩展名的情况，会按.js、.json、.node的次序补足扩展名，依次尝试。尝试需要调用fs模块同步阻塞式地判断文件是否存在。因为node单线程，会引起性能问题。所以，如果是.node和.json文件，带上扩展名，会快一点；同步配合缓存，可以大幅度缓解node单线程中阻塞式调用的缺陷
- 目录分析和包：require分析文件扩展名之后可能没有查找到对用文件，但却得到一个目录，在引入自定义模块和逐个模块路径进行查找时经常会出现，此时会将目录当作一个包来处理。首先，在当下目录查找package.json，通过JSON.parse()解析出包描述对象，从中取出main属性置顶的文件名进行定位。如果缺少扩展名，将会进入扩展名分析的步骤。如果main指定的文件名错误，或压根没有package.json文件，会将index当作默认文件名，然后依次查找index.js、index.json、index.node。如果没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有找到，则会抛出查找失败的异常。

1. 模块编译：定位到文件后，node会新建一个模块对象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法不同：

.js文件：通过fs模块同步读取文件后编译执行。

.node文件：用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件

.json文件：通过fs模块同步读取文件后，用JSON.parse()解析返回结果

其余扩展名文件：都被当成.js文件载入

每一个编译成功的模块都会将文件路径作为索引缓存在Module._cache对象上，以提高二次引入的性能。